â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    RESTOTUP - SISTEMA DE GESTIÃ“N DE RESTAURANTE
                        DOCUMENTACIÃ“N TÃ‰CNICA COMPLETA
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ÃNDICE
â•â•â•â•â•â•
1. DescripciÃ³n General del Sistema
2. Arquitectura y TecnologÃ­as Utilizadas
3. Estructura de la Base de Datos
4. MÃ³dulos del Sistema
5. Funcionalidades Principales
6. Sistema de Alertas Telegram
7. Flujo de Trabajo del Sistema
8. Decisiones de DiseÃ±o y JustificaciÃ³n
9. InstalaciÃ³n y ConfiguraciÃ³n
10. Conclusiones


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
1. DESCRIPCIÃ“N GENERAL DEL SISTEMA
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

RestoTup es un sistema de gestiÃ³n integral para restaurantes desarrollado con 
Django (Python), que permite administrar todos los aspectos operativos de un
establecimiento gastronÃ³mico.

OBJETIVO PRINCIPAL:
Proporcionar una soluciÃ³n completa para:
- GestiÃ³n de inventario y productos
- Control de recetas y costos
- AdministraciÃ³n de pedidos
- GestiÃ³n de clientes (minoristas y empresariales)
- GestiÃ³n de personal
- Sistema de alertas automÃ¡ticas
- Reportes mensuales de uso y ventas

ALCANCE:
El sistema estÃ¡ diseÃ±ado para restaurantes pequeÃ±os a medianos que necesitan
control detallado de sus operaciones, con Ã©nfasis en:
- Trazabilidad de ingredientes
- Control de costos por receta
- GestiÃ³n de stock en tiempo real
- AnÃ¡lisis de consumo mensual


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
2. ARQUITECTURA Y TECNOLOGÃAS UTILIZADAS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

PATRÃ“N DE ARQUITECTURA: MTV (Model-Template-View)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Django implementa una variaciÃ³n del patrÃ³n MVC llamada MTV:
- MODEL (Modelo): GestiÃ³n de datos y lÃ³gica de negocio
- TEMPLATE (Plantilla): PresentaciÃ³n y interfaz de usuario
- VIEW (Vista): LÃ³gica de control y procesamiento de requests

JUSTIFICACIÃ“N: MTV separa claramente las responsabilidades, facilitando el
mantenimiento y escalabilidad del sistema.


TECNOLOGÃAS UTILIZADAS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Back-end:
---------
- Python 3.14.0: Lenguaje principal por su sintaxis clara y productividad
- Django 4.2.26: Framework web robusto con ORM integrado y seguridad built-in
- SQLite3: Base de datos relacional ligera, perfecta para desarrollo/testing

  JUSTIFICACIÃ“N SQLite:
  * No requiere servidor de BD separado
  * Ideal para pequeÃ±os/medianos volÃºmenes de datos
  * FÃ¡cil portabilidad (archivo Ãºnico)
  * Para producciÃ³n se puede migrar fÃ¡cilmente a PostgreSQL/MySQL

LibrerÃ­as Adicionales:
---------------------
- python-decouple: GestiÃ³n segura de variables de entorno (.env)
- requests: Consumo de API de Telegram para notificaciones

  JUSTIFICACIÃ“N python-decouple:
  * Separa configuraciÃ³n del cÃ³digo (12 Factor App)
  * Tokens sensibles (Telegram) no quedan hardcodeados
  * Facilita despliegue en diferentes entornos

Front-end:
----------
- HTML5: Estructura semÃ¡ntica
- CSS3: Estilos personalizados con gradientes y efectos modernos
- Font Awesome 6.0: IconografÃ­a profesional
- Google Fonts (Inter): TipografÃ­a moderna y legible

  DECISIÃ“N DE DISEÃ‘O: No se utilizÃ³ framework CSS (Bootstrap, Tailwind) para
  tener control total sobre el diseÃ±o y optimizar el rendimiento evitando CSS
  innecesario.

ConfiguraciÃ³n Regional:
----------------------
- LANGUAGE_CODE: 'es-ar' (EspaÃ±ol Argentina)
- TIME_ZONE: 'America/Argentina/Buenos_Aires'
- Esto asegura formatos de fecha/hora correctos para usuarios argentinos


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
3. ESTRUCTURA DE LA BASE DE DATOS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

El sistema estÃ¡ organizado en 5 aplicaciones Django independientes pero
relacionadas:


APLICACIÃ“N: PRODUCTOS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Modelos:
--------

1. CategoriaProducto
   - PropÃ³sito: Clasificar productos para mejor organizaciÃ³n
   - Campos:
     * nombre: CharField con choices (ingredientes, limpieza, packaging, 
       bebidas, otros)
     * descripcion: TextField opcional
   
   DECISIÃ“N: Usar choices en lugar de tabla abierta para mantener categorÃ­as
   controladas y evitar duplicados.

2. UnidadMedida
   - PropÃ³sito: Estandarizar mediciones (kg, litros, unidades)
   - Campos:
     * nombre: Nombre completo (ej: "Kilogramos")
     * abreviatura: VersiÃ³n corta (ej: "kg")
   
   DECISIÃ“N: Tabla separada permite agregar nuevas unidades sin modificar cÃ³digo.

3. Producto
   - PropÃ³sito: Inventario principal del restaurante
   - Campos:
     * nombre: IdentificaciÃ³n del producto
     * categoria: FK a CategoriaProducto (PROTECT - no permite borrar 
       categorÃ­as en uso)
     * unidad_medida: FK a UnidadMedida (PROTECT)
     * stock_actual: DecimalField (precisiÃ³n 2 decimales para cantidades exactas)
     * stock_minimo: Umbral para alertas
     * precio_unitario: Costo del producto
     * activo: BooleanField para desactivar sin borrar
     * fecha_creacion/actualizacion: Timestamps automÃ¡ticos
   
   Propiedades calculadas:
     * stock_bajo: Valida si stock_actual <= stock_minimo
     * porcentaje_stock: Calcula (stock_actual / stock_minimo) * 100
   
   DECISIONES CLAVE:
   - DecimalField en lugar de FloatField para evitar errores de redondeo en
     cÃ¡lculos monetarios
   - on_delete=PROTECT en ForeignKeys para prevenir borrado accidental de datos
     relacionados
   - Campo 'activo' permite "soft delete" manteniendo histÃ³rico


APLICACIÃ“N: RECETAS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Modelos:
--------

1. Receta
   - PropÃ³sito: Platos que se ofrecen a clientes
   - Campos:
     * nombre: Nombre del plato
     * descripcion: Detalles de preparaciÃ³n
     * precio_venta: Precio al cliente
     * activa: Control de disponibilidad
     * fecha_creacion: Timestamp
   
   MÃ©todos:
     * calcular_costo(): Suma precio_unitario * cantidad de todos ingredientes
     * verificar_stock_disponible(cantidad): Valida stock antes de preparar
   
   DECISIÃ“N: Separar precio_venta de costo permite anÃ¡lisis de rentabilidad

2. IngredienteReceta
   - PropÃ³sito: Relacionar recetas con productos (tabla intermedia)
   - Campos:
     * receta: FK a Receta (CASCADE - si borro receta, borro ingredientes)
     * producto: FK a Producto (PROTECT - no puedo borrar producto usado)
     * cantidad: Cantidad necesaria del producto
   
   DECISIÃ“N ARQUITECTURAL:
   - RelaciÃ³n Many-to-Many personalizada (en lugar de ManyToManyField simple)
     permite almacenar cantidad especÃ­fica para cada ingrediente
   - unique_together evita duplicar mismo producto en una receta


APLICACIÃ“N: CLIENTES
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Modelos:
--------

1. Cliente (Abstracto)
   - PropÃ³sito: Modelo base con campos comunes
   - Campos compartidos: nombre, direccion, numero, activo, fecha_creacion
   
   PATRÃ“N: Herencia de modelos Django (Abstract Base Class)

2. ClienteMinorista (Hereda de Cliente)
   - PropÃ³sito: Clientes individuales
   - Solo hereda campos base, no requiere campos adicionales

3. ClienteEmpresa (Hereda de Cliente)
   - PropÃ³sito: Clientes corporativos
   - Campos adicionales:
     * cuit: IdentificaciÃ³n fiscal (unique)
     * razon_social: Nombre legal
   
   DECISIÃ“N ARQUITECTURAL:
   - Usar herencia en lugar de campo "tipo_cliente" porque:
     * Evita campos NULL innecesarios (CUIT en minoristas)
     * Permite agregar mÃ©todos especÃ­ficos por tipo
     * Mejor integridad referencial


APLICACIÃ“N: PERSONAL
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Modelo:
-------

Empleado
   - PropÃ³sito: Registro de empleados del restaurante
   - Campos:
     * nombre, apellido: IdentificaciÃ³n
     * rol: CharField con choices (jefe, encargado, cocina, mostrador)
     * telefono, email: Contacto
     * fecha_ingreso: Control de antigÃ¼edad
     * activo: Control de empleados actuales
   
   Propiedades:
     * nombre_completo: Concatena nombre + apellido
   
   DECISIÃ“N: Campo 'rol' con choices en lugar de tabla separada porque los
   roles son fijos y no cambian frecuentemente.


APLICACIÃ“N: PEDIDOS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Modelos:
--------

1. Pedido
   - PropÃ³sito: Ã“rdenes de clientes
   - Features especiales:
     * Generic Foreign Key: Permite relacionar con ClienteMinorista O
       ClienteEmpresa sin duplicar estructura
     * Campos:
       - content_type: Identifica tipo de cliente
       - object_id: ID del cliente especÃ­fico
       - cliente: GenericForeignKey virtual
       - empleado: Quien tomÃ³ el pedido
       - estado: CharField con choices (pendiente, en_preparacion, 
         completado, cancelado)
       - total: DecimalField calculado
       - observaciones: Notas adicionales
   
   MÃ©todos:
     * calcular_total(): Suma subtotales de todos los ItemPedido
     * get_nombre_cliente(): Maneja diferencia entre minorista y empresa
   
   DECISIÃ“N TÃ‰CNICA AVANZADA - Generic Foreign Keys:
   ------------------------------------------------
   Permite que un pedido apunte a diferentes tipos de clientes sin crear
   dos tablas separadas. Alternativas descartadas:
   - FK a ambos tipos (uno NULL): Confuso y propenso a errores
   - Unificar clientes: PerderÃ­a ventajas de la herencia
   
   Ventaja: Flexibilidad - podrÃ­amos agregar nuevos tipos de clientes sin
   modificar modelo Pedido.

2. ItemPedido
   - PropÃ³sito: LÃ­neas individuales del pedido (quÃ© recetas se pidieron)
   - Campos:
     * pedido: FK a Pedido (CASCADE - items se borran con el pedido)
     * receta: FK a Receta (PROTECT - no borrar recetas usadas)
     * cantidad: Unidades pedidas
     * precio_unitario: Precio al momento del pedido
   
   Propiedades:
     * subtotal: precio_unitario * cantidad
   
   DECISIÃ“N CRÃTICA:
   - Guardar precio_unitario en el momento del pedido (no usar FK.precio_venta)
     porque los precios pueden cambiar y necesitamos histÃ³rico exacto.
   - Override del mÃ©todo save() para capturar precio automÃ¡ticamente

3. UsoProducto
   - PropÃ³sito: Registro histÃ³rico para reportes mensuales
   - Campos:
     * producto: FK a Producto
     * cantidad: Cantidad usada
     * mes, anio: Para agrupar en reportes
     * pedido: Trazabilidad opcional
     * fecha: Timestamp
   
   DECISIÃ“N: Tabla separada de histÃ³rico permite:
   - Reportes rÃ¡pidos sin recalcular
   - Mantener datos aunque se borren pedidos (si pedido fuera requerido)
   - AnÃ¡lisis temporal de tendencias


DIAGRAMA DE RELACIONES
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

CategoriaProducto â”€â”
                   â”‚
UnidadMedida â”€â”€â”€â”€â”€â”€â”¼â”€â”€> Producto â”€â”€â”
                   â”‚                â”‚
                   â”‚                â”œâ”€â”€> IngredienteReceta <â”€â”€ Receta
                   â”‚                â”‚                           â”‚
                   â”‚                â””â”€â”€> UsoProducto           â”‚
                   â”‚                                            â”‚
Empleado â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€> Pedido <â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
                   â”‚                      â”‚                     â”‚
ClienteMinorista â”€â”€â”¤                      â”‚                     â”‚
                   â”‚                      â””â”€â”€> ItemPedido â”€â”€â”€â”€â”€â”€â”˜
ClienteEmpresa â”€â”€â”€â”€â”˜


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
4. MÃ“DULOS DEL SISTEMA
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

PRODUCTOS (/productos/)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Funcionalidades:
- Lista de productos con filtros por categorÃ­a
- Crear/editar/eliminar productos
- Indicadores visuales de stock bajo
- BÃºsqueda por nombre

Vistas principales:
- lista_productos: Muestra todos productos con opciÃ³n de filtrar
- crear_producto: Formulario de alta
- editar_producto: ModificaciÃ³n de datos
- eliminar_producto: Baja lÃ³gica (activo=False)

CaracterÃ­sticas UI:
- Cards con gradientes de color segÃºn nivel de stock
- Badges de alerta para stock bajo
- Iconos Font Awesome para mejor UX


RECETAS (/recetas/)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Funcionalidades:
- GestiÃ³n completa de recetas
- AsignaciÃ³n de ingredientes con cantidades
- CÃ¡lculo automÃ¡tico de costos
- ValidaciÃ³n de stock antes de preparar

Vistas principales:
- lista_recetas: CatÃ¡logo de platos
- crear_receta: Alta de nueva receta
- receta_detail: Vista detallada con ingredientes y costos
- editar_receta: ModificaciÃ³n
- agregar_ingrediente: AÃ±adir productos a receta
- eliminar_ingrediente: Quitar ingredientes

Features destacadas:
- CÃ¡lculo en tiempo real de costo total
- ComparaciÃ³n costo vs precio de venta (margen)
- VerificaciÃ³n automÃ¡tica de disponibilidad de stock


CLIENTES (/clientes/)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Funcionalidades:
- GestiÃ³n separada de minoristas y empresas
- Alta/baja/modificaciÃ³n
- Listados filtrados

Vistas principales:
- lista_clientes_minoristas / lista_clientes_empresas: Listados separados
- crear_cliente_minorista / crear_cliente_empresa: Forms especÃ­ficos
- editar_cliente_X: Modificaciones
- eliminar_cliente_X: Bajas lÃ³gicas

DECISIÃ“N UI:
Separar visualmente los tipos de cliente facilita la operaciÃ³n diaria y evita
confusiÃ³n entre requisitos (CUIT para empresas).


PERSONAL (/personal/)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Funcionalidades:
- Registro de empleados
- AsignaciÃ³n de roles
- Control de activos/inactivos

Vistas principales:
- lista_empleados: Roster completo
- crear_empleado: Alta
- editar_empleado: ModificaciÃ³n
- eliminar_empleado: Baja lÃ³gica

Feature importante:
- Filtro por rol para asignar responsabilidades


PEDIDOS (/pedidos/)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Funcionalidades:
- CreaciÃ³n de pedidos (selecciÃ³n cliente + recetas)
- GestiÃ³n de estados (workflow)
- CÃ¡lculo automÃ¡tico de totales
- Descuento automÃ¡tico de stock
- Reportes mensuales

Vistas principales:
- lista_pedidos: Todos los pedidos con filtros por estado
- crear_pedido: Wizard de creaciÃ³n
- pedido_detail: Vista detallada
- cambiar_estado_pedido: Workflow management
- reportes_mensuales: AnÃ¡lisis de uso y ventas

LÃ“GICA DE NEGOCIO CRÃTICA:
--------------------------

Al completar un pedido (cambiar a estado 'completado'):
1. Se descuenta stock de productos (mediante ingredientes de recetas)
2. Se registra uso en tabla UsoProducto para reportes
3. Se verifica stock mÃ­nimo y dispara alerta Telegram si necesario
4. Se actualiza total del pedido

CÃ³digo en pedidos/views.py::cambiar_estado_pedido():
```python
if nuevo_estado == 'completado':
    for item in pedido.items.all():
        for ingrediente in item.receta.ingredientes.all():
            producto = ingrediente.producto
            cantidad_total = ingrediente.cantidad * item.cantidad
            producto.stock_actual -= cantidad_total
            producto.save()
            
            # Registrar uso para reportes
            UsoProducto.objects.create(...)
            
            # Verificar stock bajo
            if producto.stock_bajo:
                enviar_alerta_telegram(producto)
```


DASHBOARD (/)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Funcionalidades:
- Vista general del estado del sistema
- MÃ©tricas rÃ¡pidas (total productos, recetas, clientes, pedidos)
- Accesos directos a funciones principales
- Alertas de stock bajo
- Indicador de empleados activos

DECISIÃ“N UX:
Dashboard como landing page permite vista panorÃ¡mica inmediata del negocio.


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
5. FUNCIONALIDADES PRINCIPALES
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

GESTIÃ“N DE INVENTARIO
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Control de Stock en Tiempo Real:
- ActualizaciÃ³n automÃ¡tica al completar pedidos
- CÃ¡lculo de stock necesario por receta
- ValidaciÃ³n antes de confirmar pedido
- Indicadores visuales (colores) segÃºn nivel

Alertas de Stock Bajo:
- VerificaciÃ³n automÃ¡tica al descontar stock
- ComparaciÃ³n con stock_minimo
- NotificaciÃ³n Telegram inmediata


COSTEO DE RECETAS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Sistema de CÃ¡lculo Multinivel:
1. Precio base de productos (precio_unitario)
2. Cantidad de cada ingrediente en receta
3. Suma total = COSTO DE RECETA
4. ComparaciÃ³n con precio_venta = MARGEN

FÃ³rmula implementada:
```
Costo_Receta = Î£ (Producto.precio_unitario * IngredienteReceta.cantidad)
Margen = ((precio_venta - Costo_Receta) / precio_venta) * 100
```

Ventaja comercial: Permite decisiones informadas sobre pricing


WORKFLOW DE PEDIDOS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Estados del Pedido:
1. PENDIENTE: Cliente ordenÃ³, aÃºn no se prepara
2. EN_PREPARACION: Cocina estÃ¡ trabajando
3. COMPLETADO: Entregado y cobrado
4. CANCELADO: Anulado

Transiciones vÃ¡lidas:
- pendiente â†’ en_preparacion
- pendiente â†’ cancelado
- en_preparacion â†’ completado
- en_preparacion â†’ cancelado

DECISIÃ“N: No permitir cambios retroactivos (completado â†’ pendiente) para
mantener integridad del stock y reportes.


REPORTES MENSUALES
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Vista de AnÃ¡lisis:
- SelecciÃ³n de mes/aÃ±o mediante dropdowns
- Total de pedidos completados en el perÃ­odo
- Total vendido (suma de totales de pedidos)
- Ranking de productos mÃ¡s utilizados

Query optimizada para performance:
```python
productos_usados = UsoProducto.objects.filter(
    mes=mes, anio=anio
).values(
    'producto__nombre',
    'producto__unidad_medida__abreviatura'
).annotate(
    total_usado=Sum('cantidad')
).order_by('-total_usado')[:10]
```

DECISIÃ“N: Usar tabla UsoProducto precalculada en lugar de recorrer todos
los pedidos cada vez (performance O(n) vs O(nÂ²)).


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
6. SISTEMA DE ALERTAS TELEGRAM
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

INTEGRACIÃ“N CON TELEGRAM BOT API
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ConfiguraciÃ³n (settings.py):
```python
TELEGRAM_BOT_TOKEN = config('TELEGRAM_BOT_TOKEN')
TELEGRAM_CHAT_ID = config('TELEGRAM_CHAT_ID')
STOCK_MINIMO_ALERTA = 10
```

FunciÃ³n de EnvÃ­o (utils.py):
```python
import requests

def enviar_alerta_telegram(producto):
    url = f"https://api.telegram.org/bot{BOT_TOKEN}/sendMessage"
    mensaje = f"ğŸš¨ ALERTA DE STOCK BAJO\n\n"
              f"Producto: {producto.nombre}\n"
              f"Stock actual: {producto.stock_actual} {producto.unidad_medida}\n"
              f"Stock mÃ­nimo: {producto.stock_minimo}"
    
    requests.post(url, data={
        'chat_id': CHAT_ID,
        'text': mensaje,
        'parse_mode': 'HTML'
    })
```

JUSTIFICACIÃ“N TÃ‰CNICA:
---------------------

Â¿Por quÃ© Telegram y no email/SMS?
- Telegram es gratuito (SMS cuesta)
- Notificaciones push inmediatas
- No requiere servidor de email
- API simple sin autenticaciÃ³n compleja
- Permite crear bots sin coding en Telegram

Â¿Por quÃ© no WhatsApp Business API?
- Requiere aprobaciÃ³n de Meta
- Costos por mensaje
- Setup mÃ¡s complejo

Flujo de Alerta:
1. Usuario completa pedido
2. Sistema descuenta stock
3. Verifica if producto.stock_actual <= producto.stock_minimo
4. Si cumple: POST a Telegram API
5. Bot envÃ­a mensaje al chat configurado

CONFIGURACIÃ“N INICIAL:
1. Crear bot en Telegram (@BotFather)
2. Obtener token
3. Crear grupo/canal
4. Agregar bot al grupo
5. Obtener chat_id
6. Configurar en .env


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
7. FLUJO DE TRABAJO DEL SISTEMA
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

CASO DE USO COMPLETO: ATENDER UN PEDIDO
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Escenario: Cliente pide 2 hamburguesas y 1 ensalada

PASO 1: Login
-------------
- Usuario ingresa a sistema
- Django Auth valida credenciales
- Redirige a dashboard

PASO 2: Verificar Stock
-----------------------
- Empleado revisa /productos/ para confirmar ingredientes disponibles
- Sistema muestra badges visuales de stock

PASO 3: Crear Pedido
--------------------
URL: /pedidos/crear/

Substeps:
a) Seleccionar tipo de cliente (minorista/empresa)
b) Seleccionar cliente especÃ­fico del dropdown
c) Sistema carga formulario de items
d) Empleado agrega:
   - Receta: Hamburguesa, Cantidad: 2
   - Receta: Ensalada, Cantidad: 1
e) Sistema calcula automÃ¡ticamente:
   - Subtotal item 1: precio_venta(Hamburguesa) * 2
   - Subtotal item 2: precio_venta(Ensalada) * 1
   - Total pedido: suma subtotales
f) Empleado guarda (estado inicial: PENDIENTE)

CÃ³digo ejecutado:
```python
pedido = Pedido.objects.create(
    cliente=cliente_seleccionado,
    empleado=request.user.empleado,
    estado='pendiente'
)

for item in form.cleaned_data['items']:
    ItemPedido.objects.create(
        pedido=pedido,
        receta=item['receta'],
        cantidad=item['cantidad'],
        precio_unitario=item['receta'].precio_venta
    )

pedido.calcular_total()
pedido.save()
```

PASO 4: Pasar a Cocina
----------------------
URL: /pedidos/{id}/cambiar-estado/

- Encargado cambia estado a 'en_preparacion'
- Sistema actualiza timestamp

PASO 5: Completar Pedido
-------------------------
- Cuando plato estÃ¡ listo y cobrado, cambiar a 'completado'

LÃ“GICA EJECUTADA (CRÃTICA):
```python
if nuevo_estado == 'completado':
    mes_actual = timezone.now().month
    anio_actual = timezone.now().year
    
    for item in pedido.items.all():
        receta = item.receta
        cantidad_platos = item.cantidad
        
        for ingrediente in receta.ingredientes.all():
            producto = ingrediente.producto
            cantidad_necesaria = ingrediente.cantidad * cantidad_platos
            
            # Descontar stock
            producto.stock_actual -= cantidad_necesaria
            producto.save()
            
            # Registrar uso mensual
            UsoProducto.objects.create(
                producto=producto,
                cantidad=cantidad_necesaria,
                mes=mes_actual,
                anio=anio_actual,
                pedido=pedido
            )
            
            # Verificar alerta
            if producto.stock_actual <= producto.stock_minimo:
                enviar_alerta_telegram(producto)
```

Resultado:
- Stock actualizado en DB
- Registro histÃ³rico creado
- Alerta Telegram enviada (si aplica)
- Pedido marcado como completado


CASO DE USO: CONSULTAR REPORTE MENSUAL
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

URL: /pedidos/reportes/

PASO 1: Seleccionar PerÃ­odo
---------------------------
- Usuario selecciona mes (1-12) y aÃ±o
- Form GET con parÃ¡metros: ?mes=11&anio=2025

PASO 2: Sistema Procesa
-----------------------
```python
pedidos_mes = Pedido.objects.filter(
    fecha__month=mes,
    fecha__year=anio,
    estado='completado'
).aggregate(
    total_pedidos=Count('id'),
    total_vendido=Sum('total')
)

productos_usados = UsoProducto.objects.filter(
    mes=mes,
    anio=anio
).values(
    'producto__nombre',
    'producto__unidad_medida__abreviatura'
).annotate(
    total_usado=Sum('cantidad')
).order_by('-total_usado')[:10]
```

PASO 3: Renderizar Resultado
----------------------------
Template muestra:
- Cards con mÃ©tricas (pedidos, ventas)
- Tabla con top 10 productos mÃ¡s usados
- Emojis de medallas (ğŸ¥‡ğŸ¥ˆğŸ¥‰) para top 3

OPTIMIZACIÃ“N:
Usar aggregate/annotate de Django ORM en lugar de loops Python resulta en
queries SQL optimizadas con GROUP BY y SUM.


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
8. DECISIONES DE DISEÃ‘O Y JUSTIFICACIÃ“N
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ARQUITECTURA
â•â•â•â•â•â•â•â•â•â•â•â•â•

1. Â¿Por quÃ© Django y no Flask/FastAPI?
   
   Django ofrece:
   - ORM completo (evita escribir SQL manual)
   - Admin automÃ¡tico para testing rÃ¡pido
   - Sistema de autenticaciÃ³n incluido
   - Migraciones de BD automÃ¡ticas
   - Templating engine integrado
   
   Flask requerirÃ­a:
   - Instalar ORM separado (SQLAlchemy)
   - Implementar auth manualmente
   - Configurar todo desde cero
   
   ConclusiÃ³n: Django = desarrollo mÃ¡s rÃ¡pido para MVPs


2. Â¿Por quÃ© SQLite y no PostgreSQL/MySQL?
   
   SQLite ventajas:
   - Archivo Ãºnico, fÃ¡cil backup (copiar db.sqlite3)
   - No requiere servidor corriendo
   - Perfecta para desarrollo
   - MigraciÃ³n sencilla a otros DB cuando escale
   
   Desventajas (aceptadas para este alcance):
   - No soporta concurrencia alta
   - Algunas features SQL limitadas
   
   DecisiÃ³n: Suficiente para restaurante pequeÃ±o/mediano


3. Â¿Por quÃ© Generic Foreign Keys para clientes?
   
   Alternativas evaluadas:
   
   a) Dos FK (cliente_minorista, cliente_empresa):
      Pros: Simple
      Cons: Siempre uno NULL, validaciones complejas
   
   b) Unificar en tabla Cliente con tipo:
      Pros: Un solo FK
      Cons: Campos opcionales (CUIT a veces NULL), pierde herencia
   
   c) Generic FK (ELEGIDO):
      Pros: Flexible, permite agregar tipos sin cambiar Pedido
      Cons: Queries un poco mÃ¡s complejas
   
   DecisiÃ³n: Flexibilidad futura > simplicidad inmediata


BASE DE DATOS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•

4. Â¿DecimalField o FloatField para dinero?
   
   SIEMPRE DecimalField porque:
   - Float tiene errores de redondeo (0.1 + 0.2 != 0.3)
   - Decimal es exacto
   - CrÃ­tico para cÃ¡lculos financieros
   
   Ejemplo bug con Float:
   ```python
   >>> 0.1 + 0.2
   0.30000000000000004  # ERROR!
   
   >>> from decimal import Decimal
   >>> Decimal('0.1') + Decimal('0.2')
   Decimal('0.3')  # CORRECTO
   ```


5. Â¿Por quÃ© on_delete=PROTECT en ForeignKeys?
   
   Previene dataloss accidental:
   - No puedo borrar Producto si estÃ¡ en Receta
   - No puedo borrar Receta si estÃ¡ en Pedido
   
   Alternativas:
   - CASCADE: BorrarÃ­a en cascada (peligroso)
   - SET_NULL: PerderÃ­a referencia (malo para auditorÃ­a)
   
   DecisiÃ³n: Integridad > comodidad


6. Â¿Soft delete (activo=False) o DELETE real?
   
   Soft delete porque:
   - Mantiene histÃ³rico
   - Permite "reactivar" si fue error
   - Reportes pueden incluir datos histÃ³ricos
   - AuditorÃ­a completa
   
   Trade-off: BD crece mÃ¡s, pero storage es barato


INTERFAZ DE USUARIO
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

7. Â¿Por quÃ© CSS custom y no Bootstrap?
   
   - Control total sobre diseÃ±o
   - Menos KB descargados (performance)
   - Aprendizaje de CSS puro
   - No depender de versiones de frameworks
   
   Trade-off: MÃ¡s trabajo inicial, pero UI Ãºnica


8. Â¿Por quÃ© Font Awesome?
   
   - Iconos vectoriales (escalables)
   - Consistencia visual
   - MÃ¡s profesional que emojis
   - CDN rÃ¡pido


SEGURIDAD
â•â•â•â•â•â•â•â•â•â•

9. Â¿Por quÃ© python-decouple para variables de entorno?
   
   Seguridad segÃºn 12 Factor App:
   - Tokens en .env (no en cÃ³digo)
   - .env en .gitignore (no sube a GitHub)
   - Diferentes .env por ambiente (dev/prod)
   
   Sin esto: Tokens quedarÃ­an hardcoded y expuestos


10. Â¿Por quÃ© LOGIN_REQUIRED en vistas?
    
    ProtecciÃ³n bÃ¡sica:
    - Solo usuarios autenticados acceden
    - Previene uso no autorizado
    - Trazabilidad (quiÃ©n hizo quÃ©)


LÃ“GICA DE NEGOCIO
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

11. Â¿Por quÃ© guardar precio_unitario en ItemPedido?
    
    HistÃ³rico exacto:
    - Precios cambian con el tiempo
    - Necesito saber quÃ© se cobrÃ³ REALMENTE
    - Reportes histÃ³ricos precisos
    
    Alternativa (mala):
    - Usar item.receta.precio_venta siempre
    - Problema: Si cambio precio hoy, cambiarÃ­a pedidos pasados


12. Â¿Por quÃ© tabla UsoProducto separada?
    
    Performance en reportes:
    - Precalculado en el momento
    - Query rÃ¡pida (GROUP BY mes/aÃ±o)
    
    Sin esto:
    - Calcular cada reporte recorriendo todos pedidos
    - Complejidad O(nÂ²): productos * pedidos * items
    - Con 1000 pedidos = lento


13. Â¿Por quÃ© unique_together en IngredienteReceta?
    
    Previene bugs:
    - No puedo agregar "Tomate" dos veces a misma receta
    - ValidaciÃ³n a nivel BD (mÃ¡s seguro que cÃ³digo)


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
9. INSTALACIÃ“N Y CONFIGURACIÃ“N
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

REQUISITOS PREVIOS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
- Python 3.8+
- pip (gestor de paquetes Python)
- Git (opcional para clonar repo)

PASOS DE INSTALACIÃ“N
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

1. Clonar/Descargar Proyecto
   ```
   cd Desktop
   (Proyecto ya estÃ¡ en Desktop/restotup)
   ```

2. Crear Entorno Virtual
   ```
   python -m venv venv
   ```
   
   PropÃ³sito: Aislar dependencias del proyecto del Python global

3. Activar Entorno Virtual
   ```
   # Windows
   venv\Scripts\activate
   
   # Linux/Mac
   source venv/bin/activate
   ```

4. Instalar Dependencias
   ```
   pip install -r requirements.txt
   ```
   
   Contenido requirements.txt:
   - Django==4.2.26
   - python-decouple
   - requests

5. Configurar Variables de Entorno
   
   Crear archivo .env en raÃ­z del proyecto:
   ```
   TELEGRAM_BOT_TOKEN=tu_token_aqui
   TELEGRAM_CHAT_ID=tu_chat_id_aqui
   ```
   
   (Opcional: Sistema funciona sin esto, solo sin alertas Telegram)

6. Aplicar Migraciones
   ```
   python manage.py migrate
   ```
   
   Esto crea tablas en db.sqlite3

7. Crear Datos Iniciales (Opcional)
   ```
   python crear_datos_iniciales.py
   ```
   
   Carga ejemplos de productos, recetas, clientes

8. Crear Superusuario (Admin)
   ```
   python manage.py createsuperuser
   ```
   
   Para acceder a /admin/

9. Iniciar Servidor
   ```
   python manage.py runserver
   ```
   
   Acceder en: http://127.0.0.1:8000/


ESTRUCTURA DE DIRECTORIOS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

restotup/
â”œâ”€â”€ clientes/           # App gestiÃ³n clientes
â”‚   â”œâ”€â”€ models.py       # Modelos ClienteMinorista, ClienteEmpresa
â”‚   â”œâ”€â”€ views.py        # Vistas CRUD
â”‚   â”œâ”€â”€ urls.py         # Rutas
â”‚   â””â”€â”€ templates/      # Plantillas HTML
â”œâ”€â”€ productos/          # App inventario
â”‚   â”œâ”€â”€ models.py       # Producto, Categoria, UnidadMedida
â”‚   â”œâ”€â”€ views.py
â”‚   â””â”€â”€ ...
â”œâ”€â”€ recetas/            # App recetas
â”‚   â”œâ”€â”€ models.py       # Receta, IngredienteReceta
â”‚   â””â”€â”€ ...
â”œâ”€â”€ personal/           # App empleados
â”‚   â”œâ”€â”€ models.py       # Empleado
â”‚   â””â”€â”€ ...
â”œâ”€â”€ pedidos/            # App pedidos
â”‚   â”œâ”€â”€ models.py       # Pedido, ItemPedido, UsoProducto
â”‚   â”œâ”€â”€ views.py        # LÃ³gica de workflow
â”‚   â”œâ”€â”€ utils.py        # Alerta Telegram
â”‚   â””â”€â”€ ...
â”œâ”€â”€ restotup/           # ConfiguraciÃ³n proyecto
â”‚   â”œâ”€â”€ settings.py     # Config Django
â”‚   â”œâ”€â”€ urls.py         # Rutas principales
â”‚   â””â”€â”€ wsgi.py
â”œâ”€â”€ static/             # CSS, JS, imÃ¡genes
â”œâ”€â”€ templates/          # Templates globales
â”‚   â””â”€â”€ base.html       # Template base
â”œâ”€â”€ db.sqlite3          # Base de datos
â”œâ”€â”€ manage.py           # CLI Django
â””â”€â”€ requirements.txt    # Dependencias


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
10. CONCLUSIONES
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

OBJETIVOS CUMPLIDOS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

âœ“ Sistema completo de gestiÃ³n de restaurante
âœ“ Control de inventario en tiempo real
âœ“ GestiÃ³n de recetas con costeo automÃ¡tico
âœ“ Workflow de pedidos con mÃºltiples estados
âœ“ Alertas automÃ¡ticas de stock bajo
âœ“ Reportes mensuales de uso y ventas
âœ“ Interfaz moderna y responsive
âœ“ SeparaciÃ³n de tipos de clientes
âœ“ GestiÃ³n de personal por roles


TECNOLOGÃAS APLICADAS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

- PatrÃ³n MTV (separaciÃ³n de responsabilidades)
- ORM de Django (abstracciÃ³n de BD)
- Generic Foreign Keys (relaciones flexibles)
- Herencia de modelos (DRY - Don't Repeat Yourself)
- Signals/Hooks (acciones automÃ¡ticas)
- Template inheritance (reutilizaciÃ³n de UI)
- Aggregate/Annotate (queries optimizadas)
- API REST consumption (Telegram)
- Environment variables (seguridad)


CONCEPTOS AVANZADOS IMPLEMENTADOS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

1. Soft Delete: PreservaciÃ³n de datos histÃ³ricos
2. Audit Trail: Timestamps automÃ¡ticos
3. Calculated Properties: MÃ©todos @property para lÃ³gica derivada
4. Data Validation: Unique constraints, PROTECT on_delete
5. Decimal Precision: Exactitud en cÃ¡lculos monetarios
6. Denormalization: Tabla UsoProducto para performance
7. State Machine: Workflow de estados de pedido
8. Price Freezing: Guardar precio en momento de venta


ESCALABILIDAD
â•â•â•â•â•â•â•â•â•â•â•â•â•â•

El sistema estÃ¡ preparado para crecer:

1. Migrar a PostgreSQL: Cambiar 3 lÃ­neas en settings.py
2. Agregar usuarios Django: Sistema auth ya incluido
3. API REST: Posible con Django REST Framework
4. Multi-restaurant: Agregar modelo Sucursal
5. MenÃº digital: Crear app frontend conectada
6. Delivery: Extender estados de pedido


MEJORAS FUTURAS SUGERIDAS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

1. Dashboard con grÃ¡ficos (Chart.js)
2. Exportar reportes a PDF/Excel
3. IntegraciÃ³n con POS (punto de venta)
4. App mÃ³vil para tomar pedidos (React Native + API)
5. Sistema de reservas
6. GestiÃ³n de mesas
7. Propinas y divisiÃ³n de cuenta
8. IntegraciÃ³n con mercado pago/stripe


LECCIONES APRENDIDAS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

1. La planificaciÃ³n de modelos es CRÃTICA
   - Cambiar estructura despuÃ©s es costoso
   - Pensar en relaciones desde inicio

2. ValidaciÃ³n a nivel de BD > validaciÃ³n en cÃ³digo
   - unique_together, on_delete=PROTECT previenen bugs

3. OptimizaciÃ³n prematura es mala, pero queries N+1 son peores
   - select_related(), prefetch_related() esenciales

4. Testing manual es insuficiente
   - Unit tests habrÃ­an detectado bugs mÃ¡s rÃ¡pido

5. DocumentaciÃ³n del cÃ³digo es inversiÃ³n
   - Docstrings facilitan mantenimiento futuro


VALOR ACADÃ‰MICO
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Este proyecto demuestra:

âœ“ Dominio de framework web moderno (Django)
âœ“ DiseÃ±o de base de datos relacionales
âœ“ ImplementaciÃ³n de lÃ³gica de negocio compleja
âœ“ IntegraciÃ³n con APIs externas (Telegram)
âœ“ AplicaciÃ³n de buenas prÃ¡cticas (12 Factor App)
âœ“ Pensamiento en arquitectura escalable
âœ“ ResoluciÃ³n de problemas reales de negocio
âœ“ Balance entre teorÃ­a (patrones) y prÃ¡ctica (cÃ³digo funcional)


APLICABILIDAD REAL
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Este sistema puede usarse en:
- Restaurantes pequeÃ±os/medianos
- CafeterÃ­as
- PanaderÃ­as con producciÃ³n propia
- Catering empresarial
- Food trucks

Con adaptaciones menores:
- Supermercados (quitar recetas, agregar cÃ³digos de barra)
- Farmacias (agregar control de vencimientos)
- Tiendas retail (simplificar a productos + ventas)


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

RESUMEN EJECUTIVO
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

RestoTup es un sistema de gestiÃ³n de restaurantes desarrollado con Django que
integra control de inventario, costeo de recetas, workflow de pedidos y 
reportes analÃ­ticos. Utiliza arquitectura MTV, base de datos relacional SQLite,
y features avanzadas como Generic Foreign Keys, alertas Telegram en tiempo real,
y optimizaciÃ³n de queries mediante ORM de Django.

El sistema demuestra aplicaciÃ³n prÃ¡ctica de conceptos de ingenierÃ­a de software:
separaciÃ³n de responsabilidades, integridad referencial, soft delete, price
freezing, denormalization estratÃ©gica, y seguridad mediante variables de entorno.

Preparado para escalar mediante migraciÃ³n a PostgreSQL y extensiÃ³n modular a
travÃ©s de apps Django adicionales.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

INFORMACIÃ“N DEL PROYECTO
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Nombre: RestoTup
VersiÃ³n: 1.0.0
Framework: Django 4.2.26
Lenguaje: Python 3.14.0
Base de Datos: SQLite3
Autor: [Tu Nombre]
Fecha: Noviembre 2025
PropÃ³sito: Proyecto Final - [Nombre de la Materia]

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                            FIN DE LA DOCUMENTACIÃ“N
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
